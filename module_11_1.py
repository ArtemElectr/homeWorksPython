import pprint
import matplotlib.pyplot as plt
import numpy as np
import requests

#
# get запрос на сервер(параметры запроса будут в адресной строке)
# 'https://api.github.com/&key=value', params = параметры запроса после амперсанда, headers добавляет пользовательские
# HTTP-заголовки к запросу
res = requests.get('https://api.github.com/', params={'key': 'value'}, headers={'header': 'value_of_header'})
# метод json декодирует данные ответа из json
pprint.pprint(res.json())
# post запрос на сервер(параметры запроса скрыты(не указаны в адресной строке))
r = requests.post('https://httpbin.org/post', data={'key': '99'}, files={'file': '235.jpg'})

# метод url выводит URL-адрес получившегося запроса
print(res.url)
# мы можем проверить код состояния ответа
print(res.status_code)


# NumPy
a = np.array([[1, 2, 3, 5], [4, 5, 6, 1], [10, 15, 16, 4]])  # Одним из способов инициализации массива является использование
# последовательности Python, такой как список.
print(a)
print(f"атрибут ndim - {a.ndim}")  # Количество измерений массива содержится в атрибуте
print(f"атрибут shape - {a.shape}")  # выводит кортеж, где набор неотрицательных целых чисел, которые определяют
# количество элементов в каждом измерении.
print(f"атрибут size - {a.size}")  # Фиксированное общее количество элементов в массиве содержится в атрибуте
print(f"атрибут dtype - {a.dtype}")  # Массивы обычно “однородны”, что означает, что они содержат элементы только одного
# "типа данных”. Тип данных записывается в атрибуте

print(np.zeros(3))  # Помимо создания массива из последовательности элементов, вы можете легко создать массив,
# заполненный n количеством нулей, например  np.zeros(3) = [0. 0. 0.]
print(np.ones(5))   # [1. 1. 1. 1. 1.]

print(np.empty(2))  # Функция empty создает массив, начальное содержимое которого является случайным и зависит от
# состояния памяти. Причина использования empty over zeros (или чего-то подобного) заключается в скорости - просто не
# забудьте заполнить каждый элемент после этого!
print(np.arange(5)) # массив с диапазоном элементов [0 1 2 3 5]

sum_ = np.ones(5) + np.arange(5) + np.array([55, 34, 28, 69, 48]) # [56. 36. 31. 73. 53.]
mul = np.ones(5) * np.arange(5) * np.array([55, 34, 28, 69, 48]) * 2

print(f'Сумма массивов - {sum_}')
print(f'Произведение массивов и числа - {mul}')
print(f'Максимум sum_ - {sum_.max()}')
x = np.linspace(0, 2, 100) # Вы также можете использовать np.linspace() для создания массива со
# значениями, линейно расположенными через указанный интервал:


# matplotlib
fig, ax = plt.subplots()  # создание одного графика
line, = ax.plot([1, 2, 3, 4], [1, 4, 2, 3], label='base_label') # ввести данные(координаты x, y) объекта на графике
ax.set_xlabel('x_label')  # название оси х на графике
ax.set_ylabel('y_label')  # название оси y на графике
ax.set_title('Simple Plot')  # вводим название графика

line1, = ax.plot([1, 2, 3], label='label1')
line2, = ax.plot([10, 5, 3], label='label2')
ax.legend(handles=[line, line1, line2])  # вводим легенду на графике

fig_, axs = plt.subplots(2,2) # рисует 4 графика
axs[0][0].plot([1, 2, 3, 4], [1, 4, 2, 3]) # вводим координаты для левого верхнего графика


axs[0][1].plot(x, x, label='linear')    # рисуем линейную зависимость на правом верхнем графике
axs[1][0].plot(x, x**2, label='quadratic')  # рисуем квадратичную функцию на левом нижнем графике
axs[1][1].plot(x, x**3, label="cubic")  # рисуем кубическую параболу на правом нижнем графике


fig_2, axss = plt.subplot_mosaic([['left', 'right_top'], ['left', 'right_bottom']]) # рисует 3 графика, левый на всю
                                                                        # высоту и два справа высотой в половину окна
axss['right_bottom'].plot([1, 2, 3, 4], [1, 4, 2, 3]) # вводим координаты для правого нижнего графика fig_2

print(fig.axes) # метод выводит информацию об осях
plt.show()  # показать фигуру



